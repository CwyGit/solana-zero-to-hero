# 04-è¯»å†™æ•°æ® - å®‰å…¨çš„å†…å­˜æ“ä½œï¼ğŸ’¾

å˜¿ï¼Œå°ä¼™ä¼´ï¼ğŸ‘‹

åœ¨æ„å»ºä¼˜åŒ–çš„Solanaç¨‹åºæ—¶ï¼Œé«˜æ•ˆçš„æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–å¯ä»¥**æ˜¾è‘—å½±å“æ€§èƒ½**ï¼

è™½ç„¶Pinocchioä¸éœ€è¦åº•å±‚å†…å­˜æ“ä½œï¼Œä½†äº†è§£å¦‚ä½•é«˜æ•ˆåœ°è¯»å–å’Œå†™å…¥è´¦æˆ·æ•°æ®å¯ä»¥å¸®åŠ©ä½ æ„å»ºæ›´å¿«çš„ç¨‹åºï¼

**æ¯”å–»è¯´æ˜ï¼š** å°±åƒç›´æ¥æ“ä½œç¡¬ç›˜æ•°æ®ï¼Œéœ€è¦å°å¿ƒä½†æ•ˆç‡æé«˜ï¼

---

## ğŸ¯ æœ¬ç« æ ¸å¿ƒå†…å®¹

ç”±äºæœ¬ç« å†…å®¹éå¸¸æŠ€æœ¯å¯†é›†ï¼ˆ743è¡Œé«˜çº§ä»£ç ï¼‰ï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨ï¼š

- âœ… ä½•æ—¶ä½¿ç”¨unsafeä»£ç 
- âœ… ç¼“å†²åŒºè¾¹ç•Œæ£€æŸ¥
- âœ… å¯¹é½è¦æ±‚
- âœ… æ•°æ®åºåˆ—åŒ–æ–¹æ³•
- âœ… åŠ¨æ€å¤§å°æ•°æ®å¤„ç†

**å°ä¼™ä¼´ä»¬è¦ç‰¹åˆ«æ³¨æ„å•¦ï¼š**

> âš ï¸ æœ¬ç« æ¶‰åŠunsafe Rustå’Œå†…å­˜æ“ä½œï¼Œå»ºè®®æœ‰ä¸€å®šRuståŸºç¡€åå†æ·±å…¥å­¦ä¹ ï¼

**æ¯”å–»ï¼š** è¿™ç« å°±åƒå­¦å¼€æ‰‹åŠ¨æŒ¡èµ›è½¦ï¼Œéœ€è¦æŒæ¡æ›´å¤šæŠ€å·§ï¼

---

## âš ï¸ ä½•æ—¶ä½¿ç”¨unsafeä»£ç 

**é‡è¦åŸåˆ™ï¼š**

ä»…åœ¨ä»¥ä¸‹æƒ…å†µä¸‹ä½¿ç”¨unsafeä»£ç ï¼š

### 1. æ€§èƒ½å…³é”®

âœ… ä½ éœ€è¦æœ€å¤§æ€§èƒ½  
âœ… å·²ç»æµ‹é‡å‡ºå®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆè¿‡äºç¼“æ…¢  

---

### 2. å®‰å…¨ä¿è¯

âœ… ä½ å¯ä»¥ä¸¥æ ¼éªŒè¯æ‰€æœ‰å®‰å…¨ä¸å˜é‡  
âœ… ä½ æ¸…æ¥šåœ°è®°å½•äº†å®‰å…¨è¦æ±‚  

---

### 3. ä¼˜å…ˆå®‰å…¨

**å°ä¼™ä¼´ä»¬è¦ç‰¹åˆ«æ³¨æ„å•¦ï¼š**

> ğŸ’¡ å°½å¯èƒ½ä¼˜å…ˆé€‰æ‹©å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆï¼æ€§èƒ½å¾ˆé‡è¦ï¼Œä½†å®‰å…¨æ›´é‡è¦ï¼

**æ¯”å–»ï¼š** å°±åƒå¼€è½¦ç³»å®‰å…¨å¸¦ï¼Œå®‰å…¨ç¬¬ä¸€ï¼

---

## ğŸ›¡ï¸ ç¼“å†²åŒºè¾¹ç•Œæ£€æŸ¥

### ä¸ºä»€ä¹ˆé‡è¦ï¼Ÿ

åœ¨ä»»ä½•è¯»å†™æ“ä½œä¹‹å‰ï¼Œå§‹ç»ˆéªŒè¯ä½ çš„ç¼“å†²åŒºæ˜¯å¦è¶³å¤Ÿå¤§ï¼

**å±é™©ï¼š** è¶…å‡ºåˆ†é…å†…å­˜çš„è¯»å†™æ“ä½œä¼šå¯¼è‡´**æœªå®šä¹‰è¡Œä¸º**ï¼

**æ¯”å–»ï¼š** å°±åƒå¾€æ¯å­å€’æ°´ï¼Œè¦ç¡®è®¤æ¯å­å¤Ÿå¤§ï¼

---

### æ­£ç¡®åšæ³• âœ…

```rust
// Good: Check bounds first
if data.len() < size_of::<u64>() {
    return Err(ProgramError::InvalidInstructionData);
}
let value = u64::from_le_bytes(data[0..8].try_into().unwrap());
```

---

### é”™è¯¯åšæ³• âŒ

```rust
// Bad: No bounds checking - could panic or cause UB
let value = u64::from_le_bytes(data[0..8].try_into().unwrap());
```

---

## ğŸ“ å¯¹é½è¦æ±‚

### ä»€ä¹ˆæ˜¯å¯¹é½ï¼Ÿ

Rustä¸­çš„æ¯ç§ç±»å‹éƒ½æœ‰ä¸€ä¸ªå¯¹é½è¦æ±‚ï¼Œå†³å®šäº†å®ƒåœ¨å†…å­˜ä¸­çš„æ”¾ç½®ä½ç½®ï¼

**å¯¹é½è¦æ±‚ç¤ºä¾‹ï¼š**
- `u8`ï¼š1å­—èŠ‚å¯¹é½
- `u16`ï¼š2å­—èŠ‚å¯¹é½
- `u32`ï¼š4å­—èŠ‚å¯¹é½
- `u64`ï¼š8å­—èŠ‚å¯¹é½

**æ¯”å–»ï¼š** å°±åƒåœè½¦ä½ï¼Œå¤§è½¦éœ€è¦å¤§è½¦ä½ï¼Œå°è½¦éœ€è¦å°è½¦ä½ï¼

---

### å¡«å……ï¼ˆPaddingï¼‰

å¦‚æœä¸éµå®ˆå¯¹é½è¦æ±‚ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨åœ¨ç»“æ„ä½“å­—æ®µä¹‹é—´æ’å…¥ä¸å¯è§çš„"å¡«å……"å­—èŠ‚ï¼

**åæœï¼š** æµªè´¹å†…å­˜ç©ºé—´ï¼

---

### é”™è¯¯æ’åˆ—ç¤ºä¾‹ âŒ

```rust
#[repr(C)]
struct BadOrder {
    small: u8,    // 1 byte
    // padding: [u8; 7] ç¼–è¯‘å™¨è‡ªåŠ¨æ·»åŠ 7å­—èŠ‚å¡«å……
    big: u64,     // 8 bytes  
    medium: u16,  // 2 bytes
    // padding: [u8; 6] ç¼–è¯‘å™¨è‡ªåŠ¨æ·»åŠ 6å­—èŠ‚å¡«å……
}
```

**æµªè´¹ï¼š** 13å­—èŠ‚ï¼æ€»å…±24å­—èŠ‚ï¼Œå…¶ä¸­13å­—èŠ‚æ˜¯å¡«å……ï¼

---

### æ­£ç¡®æ’åˆ—ç¤ºä¾‹ âœ…

```rust
#[repr(C)]
struct GoodOrder {
    big: u64,     // 8 bytes
    medium: u16,  // 2 bytes  
    small: u8,    // 1 byte
    // padding: [u8; 5] åªéœ€è¦5å­—èŠ‚å¡«å……
}
```

**èŠ‚çœï¼š** åªæµªè´¹5å­—èŠ‚ï¼ŒèŠ‚çœäº†8å­—èŠ‚ï¼

**é»„é‡‘æ³•åˆ™ï¼š** æŒ‰ç…§å­—æ®µçš„å¯¹é½è¦æ±‚ä»å¤§åˆ°å°æ’åˆ—ç»“æ„ä½“å­—æ®µï¼Œä»¥æœ€å°åŒ–å¡«å……å¹¶å‡å°‘å†…å­˜ä½¿ç”¨ï¼

**æ¯”å–»ï¼š** å°±åƒè£…ç®±å­ï¼Œå…ˆæ”¾å¤§ä»¶ï¼Œå†æ”¾å°ä»¶ï¼Œæœ€çœç©ºé—´ï¼

---

## ğŸ”§ æ•°æ®ååºåˆ—åŒ–æ–¹æ³•

### æ–¹æ³•1ï¼šæŒ‰å­—æ®µååºåˆ—åŒ–ï¼ˆæ¨èï¼‰âœ…

æœ€å®‰å…¨çš„æ–¹æ³•æ˜¯é€ä¸ªå­—æ®µåœ°ååºåˆ—åŒ–ï¼

```rust
pub struct DepositInstructionData {
    pub amount: u64,
    pub recipient: Pubkey,
}

impl<'a> TryFrom<&'a [u8]> for DepositInstructionData {
    type Error = ProgramError;

    fn try_from(data: &'a [u8]) -> Result<Self, Self::Error> {
        if data.len() < (size_of::<u64>() + size_of::<Pubkey>()) {
            return Err(ProgramError::InvalidInstructionData);
        }

        // No alignment issues: we're reading bytes and converting
        let amount = u64::from_le_bytes(
            data[0..8].try_into()
                .map_err(|_| ProgramError::InvalidInstructionData)?
        );
        
        let recipient = Pubkey::try_from(&data[8..40])
            .map_err(|_| ProgramError::InvalidInstructionData)?;

        Ok(Self { amount, recipient })
    }
}
```

**ä¼˜ç‚¹ï¼š**
- âœ… å®Œå…¨å®‰å…¨
- âœ… æ— å¯¹é½é—®é¢˜
- âœ… æ¨èä½¿ç”¨

---

### æ–¹æ³•2ï¼šé›¶æ‹·è´ååºåˆ—åŒ–ï¼ˆé«˜æ€§èƒ½ï¼‰âš¡

å¯¹äºæ­£ç¡®å¯¹é½çš„ç»“æ„ä½“ï¼Œå¯ä»¥ä½¿ç”¨æ­¤æ–¹æ³•ä»¥è·å¾—æœ€å¤§æ€§èƒ½ï¼š

```rust
#[repr(C)]
pub struct Config {
    pub authority: Pubkey,
    pub mint_x: Pubkey, 
    pub mint_y: Pubkey,
    pub seed: u64,
    pub fee: u16,
    pub state: u8,
    pub config_bump: u8,
}

impl Config {
    pub const LEN: usize = size_of::<Self>();
    
    pub fn from_bytes(data: &[u8]) -> Result<&Self, ProgramError> {
        if data.len() != Self::LEN {
            return Err(ProgramError::InvalidAccountData);
        }

        // Critical: Check alignment
        if (data.as_ptr() as usize) % core::mem::align_of::<Self>() != 0 {
            return Err(ProgramError::InvalidAccountData);
        }

        // SAFETY: We've verified length and alignment
        Ok(unsafe { &*(data.as_ptr() as *const Self) })
    }
}
```

**å°ä¼™ä¼´ä»¬è¦ç‰¹åˆ«æ³¨æ„å•¦ï¼š**

> âš ï¸ è¿™ç§æ–¹æ³•éœ€è¦ä»”ç»†æ£€æŸ¥å¯¹é½æƒ…å†µï¼Œå¦åˆ™ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼

---

### æ–¹æ³•3ï¼šå­—èŠ‚æ•°ç»„æ–¹æ³•ï¼ˆæœ€å®‰å…¨+å¿«é€Ÿï¼‰âœ…

```rust
#[repr(C)]
pub struct ConfigSafe {
    pub authority: Pubkey,
    pub mint_x: Pubkey, 
    pub mint_y: Pubkey,
    seed: [u8; 8],      // Convert with u64::from_le_bytes
    fee: [u8; 2],       // Convert with u16::from_le_bytes
    pub state: u8,
    pub config_bump: u8,
}

impl ConfigSafe {
    pub fn seed(&self) -> u64 {
        u64::from_le_bytes(self.seed)
    }
    
    pub fn fee(&self) -> u16 {
        u16::from_le_bytes(self.fee)
    }
}
```

**ä¼˜ç‚¹ï¼š**
- âœ… å®Œå…¨å®‰å…¨
- âœ… æ— å¯¹é½é—®é¢˜
- âœ… å¿«é€Ÿç›´æ¥ä¿®æ”¹

**æ¯”å–»ï¼š** å°±åƒæŠŠå¤§æ•´æ•°æ‹†æˆå¤šä¸ªå°æ•°å­—ï¼Œæ—¢å®‰å…¨åˆçµæ´»ï¼

---

## âŒ åº”é¿å…çš„å±é™©æ¨¡å¼

### 1. ä½¿ç”¨transmuteå¤„ç†æœªå¯¹é½æ•°æ®

```rust
// âŒ UNDEFINED BEHAVIOR
let value: u64 = unsafe { core::mem::transmute(bytes_slice) };
```

**é—®é¢˜ï¼š** `transmute()`å‡è®¾æºæ•°æ®å·²é’ˆå¯¹ç›®æ ‡ç±»å‹æ­£ç¡®å¯¹é½ï¼

---

### 2. æŒ‡é’ˆè½¬æ¢ä¸ºæ‰“åŒ…ç»“æ„ä½“

```rust
#[repr(C, packed)]
pub struct PackedConfig {
    pub state: u8,
    pub seed: u64,     // This u64 is only 1-byte aligned!
}

// âŒ UNDEFINED BEHAVIOR
let config = unsafe { &*(data.as_ptr() as *const PackedConfig) };
let seed_value = config.seed; // UB!
```

---

### 3. åœ¨æœªéªŒè¯çš„æƒ…å†µä¸‹å‡è®¾å¯¹é½

```rust
// âŒ UNDEFINED BEHAVIOR: No alignment check
let config = unsafe { &*(data.as_ptr() as *const Config) };
```

---

## âœï¸ æ•°æ®åºåˆ—åŒ–æ–¹æ³•

### æ–¹æ³•1ï¼šæŒ‰å­—æ®µåºåˆ—åŒ–ï¼ˆæ¨èï¼‰âœ…

```rust
impl Config {
    pub fn write_to_buffer(&self, data: &mut [u8]) -> Result<(), ProgramError> {
        if data.len() != Self::LEN {
            return Err(ProgramError::InvalidAccountData);
        }

        let mut offset = 0;
        
        // Write authority
        data[offset..offset + 32].copy_from_slice(self.authority.as_ref());
        offset += 32;
        
        // Write seed
        data[offset..offset + 8].copy_from_slice(&self.seed.to_le_bytes());
        offset += 8;
        
        // ... more fields

        Ok(())
    }
}
```

**ä¼˜ç‚¹ï¼š**
- âœ… æœ€å®‰å…¨
- âœ… æ˜¾å¼å­—èŠ‚åº
- âœ… æ¸…æ™°çš„å†…å­˜å¸ƒå±€

---

## ğŸ“Š åŠ¨æ€å¤§å°æ•°æ®

### å•ä¸€åŠ¨æ€å­—æ®µ

å¸ƒå±€ï¼š`[å›ºå®šæ•°æ®][åŠ¨æ€æ•°æ®...]`

```rust
#[repr(C)]
pub struct DynamicAccount {
    pub fixed_data: [u8; 32],
    pub counter: u64,
    // Dynamic data follows
}

impl DynamicAccount {
    pub const FIXED_SIZE: usize = size_of::<Self>();
    
    pub fn from_bytes_with_dynamic(data: &[u8]) -> Result<(&Self, &[u8]), ProgramError> {
        if data.len() < Self::FIXED_SIZE {
            return Err(ProgramError::InvalidAccountData);
        }

        let fixed_part = unsafe { &*(data.as_ptr() as *const Self) };
        let dynamic_part = &data[Self::FIXED_SIZE..];
        
        Ok((fixed_part, dynamic_part))
    }
}
```

**æ¯”å–»ï¼š** å°±åƒé‚®ä»¶ï¼Œå‰é¢æ˜¯å›ºå®šæ ¼å¼çš„åœ°å€ï¼Œåé¢æ˜¯å¯å˜é•¿åº¦çš„å†…å®¹ï¼

---

### å¤šä¸ªåŠ¨æ€å­—æ®µ

å¸ƒå±€ï¼š`[å›ºå®šæ•°æ®][len1: u8][data1][data2: å‰©ä½™]`

**ç­–ç•¥ï¼š** ä¸ºç¬¬ä¸€ä¸ªåŠ¨æ€å­—æ®µæ·»åŠ é•¿åº¦å‰ç¼€ï¼Œç¬¬äºŒä¸ªå æ®å‰©ä½™ç©ºé—´ï¼

**æ¯”å–»ï¼š** å°±åƒå¿«é€’ï¼Œæ ‡è®°ç¬¬ä¸€ä¸ªåŒ…è£¹çš„å¤§å°ï¼Œç¬¬äºŒä¸ªè‡ªåŠ¨æ˜¯å‰©ä¸‹çš„ç©ºé—´ï¼

---

## ğŸ’¡ å­¦ä¹ å»ºè®®

### æœ¬ç« é‡ç‚¹å›é¡¾

**å¿…é¡»æŒæ¡ï¼š**
1. âœ“ æŒ‰å­—æ®µååºåˆ—åŒ–æ–¹æ³•
2. âœ“ ç¼“å†²åŒºè¾¹ç•Œæ£€æŸ¥
3. âœ“ åŸºæœ¬çš„å¯¹é½æ¦‚å¿µ

**äº†è§£å³å¯ï¼š**
- é›¶æ‹·è´ååºåˆ—åŒ–
- unsafeä»£ç çš„ä½¿ç”¨
- åŠ¨æ€å¤§å°æ•°æ®çš„é«˜çº§å¤„ç†

---

## â“ å¸¸è§é—®é¢˜

### Q1: æˆ‘å¿…é¡»ç†è§£å¯¹é½å—ï¼Ÿ

**ç­”ï¼š** å¦‚æœä½¿ç”¨æŒ‰å­—æ®µæ–¹æ³•ï¼Œä¸éœ€è¦æ·±å…¥ç†è§£ï¼

ä½†ç†è§£åŸºæœ¬æ¦‚å¿µæœ‰åŠ©äºå†™å‡ºæ›´é«˜æ•ˆçš„ä»£ç ï¼

---

### Q2: ä»€ä¹ˆæ—¶å€™ç”¨unsafeï¼Ÿ

**ç­”ï¼š** åªåœ¨æ€§èƒ½è‡³å…³é‡è¦ä¸”ä½ èƒ½ä¿è¯å®‰å…¨æ—¶ï¼

**å»ºè®®ï¼š** åˆå­¦è€…å…ˆç”¨å®‰å…¨æ–¹æ³•ï¼

---

### Q3: åŠ¨æ€æ•°æ®å¾ˆå¸¸è§å—ï¼Ÿ

**ç­”ï¼š** ä¸æ˜¯ç‰¹åˆ«å¸¸è§ï¼

å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå›ºå®šå¤§å°çš„æ•°æ®å°±å¤Ÿäº†ï¼

---

## ğŸ¯ ä¸‹ä¸€æ­¥

**å­¦å®Œè¿™ä¸€ç« ï¼Œä½ åº”è¯¥ï¼š**

- âœ“ ç†è§£æ•°æ®åºåˆ—åŒ–çš„åŸºæœ¬æ¦‚å¿µ
- âœ“ æŒæ¡å®‰å…¨çš„æŒ‰å­—æ®µæ–¹æ³•
- âœ“ äº†è§£å¯¹é½å’Œunsafeçš„æ³¨æ„äº‹é¡¹

**å‡†å¤‡å¥½äº†å—ï¼Ÿ** ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ **é”™è¯¯å¤„ç†**ï¼

---

**ç°åœ¨å°ä¼™ä¼´ä»¬æ‡‚äº†å§ï¼Ÿ** è¯»å†™æ•°æ®éœ€è¦å°å¿ƒï¼Œä½†æŒæ¡åæ€§èƒ½æå‡æ˜æ˜¾ï¼ğŸ’¾

---

**æœ€åæ›´æ–°**ï¼š2026å¹´1æœˆ9æ—¥  
**åˆ¶ä½œé£æ ¼**ï¼šè«å¼é£æ ¼  
**å­¦ä¹ å»ºè®®**ï¼šè¿™ç« å†…å®¹å¾ˆç¡¬æ ¸ï¼Œå»ºè®®å…ˆæŒæ¡å®‰å…¨æ–¹æ³•ï¼Œå†ç ”ç©¶é›¶æ‹·è´ä¼˜åŒ–ï¼

**æç¤º**ï¼šå®Œæ•´çš„ä»£ç ç¤ºä¾‹å’Œæ›´å¤šæ·±å…¥ç»†èŠ‚è¯·å‚è€ƒåŸæ–‡æ¡£çš„å®Œæ•´ç‰ˆæœ¬ï¼æœ¬ç« ä¸ºæ ¸å¿ƒæ¦‚å¿µæ€»ç»“ç‰ˆï¼